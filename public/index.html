<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PRD Writer | Explo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'DM Sans', sans-serif;
            background-color: #F5F5F5; /* Light Grey from Explo.co */
            color: #333333; /* Dark text color */
        }
        /* Custom Tailwind colors matching Explo.co */
        .bg-explo-blue { background-color: #0000FF; } /* Explo Blue */
        .bg-explo-darkblue { background-color: #000080; } /* Dark Blue/Navy */
        .text-explo-blue { color: #0000FF; }
        .border-explo-blue { border-color: #0000FF; }
        .ring-explo-blue { --tw-ring-color: #0000FF; }
        /* Simple spinner for loading states */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #0000FF; /* Explo Blue */
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 8px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Auto-resize textarea */
        .auto-resize {
            resize: none;
            overflow: hidden;
        }
        /* Progress bar moving lines animation */
        .progress-bar-container {
            position: relative;
            overflow: hidden;
        }
        .progress-bar-moving-lines {
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: moveLines 2s linear infinite;
        }
        @keyframes moveLines {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        /* Message formatting */
        .message-content {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .message-content p {
            margin-bottom: 0.5rem;
        }
        .message-content p:last-child {
            margin-bottom: 0;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">
    <main class="flex-grow container mx-auto p-4 md:p-8 flex flex-col lg:flex-row gap-8">
        <!-- PRD Assistant Sidebar -->
        <div class="lg:w-1/3 bg-white p-6 rounded-lg shadow-md flex flex-col min-h-[90vh] sticky top-0 h-[100vh] relative" style="max-height:100vh;">
            <div class="flex flex-col space-y-4 flex-grow pb-20"> <!-- Added pb-20 for logo space -->
                <h2 class="text-xl font-bold">Free PRD AI</h2>
                <p class="text-gray-600">Unlimited Free Chat with AI to build your Product Requirements Document. Conversation is saved locally in your browser.</p>
                
                <div id="status" class="text-sm text-gray-600">Ready to chat!</div>
                
                <h3 class="text-lg font-bold mt-4">Quick Start Tips</h3>
                <ul class="space-y-2 text-gray-700 text-sm">
                    <li class="text-gray-600">• Describe your product idea</li>
                    <li class="text-gray-600">• Define your target users</li>
                    <li class="text-gray-600">• Outline key features</li>
                    <li class="text-gray-600">• Discuss technical requirements</li>
                    <li class="text-gray-600">• Ask for PRD structure guidance</li>
                </ul>
                
                <div class="bg-blue-50 p-4 rounded-lg mt-4">
                    <h4 class="font-semibold text-blue-800">Example Prompts:</h4>
                    <ul class="text-sm text-blue-700 mt-2 space-y-1">
                        <li>"Help me structure a PRD for a mobile app"</li>
                        <li>"What user stories should I include?"</li>
                        <li>"Define technical requirements for my product"</li>
                    </ul>
                </div>

                <button id="clearChatBtn" class="px-4 py-2 bg-gray-500 text-white font-semibold rounded-full shadow-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75">
                    Clear Conversation
                </button>
                
                <button id="exportPrdBtn" class="mt-auto px-4 py-2 bg-green-500 text-white font-semibold rounded-full shadow-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-75 disabled:opacity-50">
                    Export Generated PRD
                    <span id="exportSpinner" class="spinner hidden"></span>
                </button>

                <!-- Progress Bar - Positioned absolutely to avoid layout shifts -->
                <div id="progressBarBlock" class="absolute left-6 right-6 bottom-24 hidden z-20">
                    <div class="bg-white rounded-lg shadow-lg p-4 flex flex-col items-center border border-gray-200">
                        <div id="progressStage" class="mb-2 text-base font-semibold text-explo-blue">Exporting PRD...</div>
                        <div class="w-full bg-gray-200 rounded-full h-4 mb-2 progress-bar-container">
                            <div id="progressBar" class="bg-explo-blue h-4 rounded-full transition-all duration-500 relative" style="width: 0%">
                                <div class="progress-bar-moving-lines"></div>
                            </div>
                        </div>
                        <div id="progressPercent" class="text-sm text-gray-700">0%</div>
                    </div>
                </div>
            </div>
            
            <!-- Explo Logo - Fixed positioning to prevent displacement -->
            <div class="absolute bottom-2 left-6 right-6 flex justify-center items-center bg-white z-10" style="height: 80px;">
                <img src="/logo-explo.png" alt="Explo Logo" class="opacity-90" style="width:100%; max-width:260px; min-width:120px; height:auto; padding: 8px 0;" />
            </div>
        </div>

        <!-- Chat Area -->
        <div class="lg:w-2/3 bg-white p-6 rounded-lg shadow-md flex flex-col">
            <h2 class="text-xl font-bold mb-4">Chat with your PRD Assistant</h2>
            <div id="chatWindow" class="flex-grow overflow-y-auto border border-gray-200 rounded-lg p-4 mb-4 space-y-4 bg-gray-50 min-h-[400px]">
                <!-- Messages will be added here dynamically -->
            </div>
            <div class="flex items-end space-x-3">
                <textarea id="chatInput" placeholder="Ask a question or describe your product idea... (Shift+Enter for new line)" class="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-explo-blue auto-resize min-h-[48px] max-h-32"></textarea>
                <button id="sendChatBtn" class="px-5 py-3 bg-explo-blue text-white font-semibold rounded-full shadow-md hover:bg-explo-darkblue focus:outline-none focus:ring-2 focus:ring-explo-blue focus:ring-opacity-75">
                    Send
                    <span id="chatSpinner" class="spinner hidden"></span>
                </button>
            </div>
            <div id="chatStatus" class="text-sm text-gray-600 mt-2"></div>
        </div>
    </main>
    <footer class="bg-explo-darkblue text-white p-4 text-center mt-8">
        <p>© 2025 Explo. All rights reserved.</p>
    </footer>

    <script>
        // Simplified conversation management using localStorage
        let conversation = [
            {
                role: 'system', 
                content: 'You are an expert Product Manager AI assistant designed to help users build Product Requirements Documents (PRDs). Your primary goal is to help users think through their product ideas and guide them through creating comprehensive PRDs. Guidelines: Ask clarifying questions to help users define their product vision. Guide them through key PRD sections: Goals, User Stories, Features, Technical Requirements, etc. Provide structured, actionable advice. Help them think about scope, timeline, and priorities. Maintain a professional, clear, and action-oriented tone.'
            }
        ];
        
        // Token optimization system
        let totalTokens = 0;
        const TOKEN_LIMIT = 3000; // Optimize every 3000 tokens
        let isOptimizing = false;
        
        // Token estimation function (rough approximation)
        function estimateTokens(text) {
            // GPT-3.5/4 uses ~4 chars per token on average
            return Math.ceil(text.length / 4);
        }
        
        // Add tokens to counter
        function addTokens(inputTokens, outputTokens = 0) {
            totalTokens += inputTokens + outputTokens;
            console.log(`Token usage: +${inputTokens + outputTokens} tokens (Total: ${totalTokens}/${TOKEN_LIMIT})`);
        }

        // UI Elements
      const chatWindow = document.getElementById('chatWindow');
      const chatInput = document.getElementById('chatInput');
      const sendChatBtn = document.getElementById('sendChatBtn');
      const exportPrdBtn = document.getElementById('exportPrdBtn');
        const clearChatBtn = document.getElementById('clearChatBtn');
      const chatStatus = document.getElementById('chatStatus');
        const status = document.getElementById('status');
      const chatSpinner = document.getElementById('chatSpinner');
      const exportSpinner = document.getElementById('exportSpinner');
  
        // Auto-resize textarea
        function autoResizeTextarea() {
            chatInput.style.height = 'auto';
            chatInput.style.height = Math.min(chatInput.scrollHeight, 128) + 'px';
        }

        // Auto-scroll chat window to bottom
        function scrollToBottom() {
            // Use multiple timeouts to ensure content is fully rendered
            setTimeout(() => {
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }, 50);
            setTimeout(() => {
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }, 150);
            setTimeout(() => {
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }, 300);
        }

        // Load conversation from localStorage on page load
        function loadConversation() {
            const saved = localStorage.getItem('prd_conversation');
            if (saved) {
                try {
                    conversation = JSON.parse(saved);
                    renderConversation();
                    showStatus(status, 'Conversation loaded from browser storage', 'success');
                } catch (e) {
                    console.error('Failed to load conversation:', e);
                    showStatus(status, 'Failed to load saved conversation', 'error');
                }
                  } else {
                // Add initial AI message
                addMessage('assistant', "Hello! I'm your PRD Assistant. Tell me about your product idea and I'll help you build a comprehensive Product Requirements Document. What would you like to create?");
            }
        }

        // Save conversation to localStorage
        function saveConversation() {
            try {
                localStorage.setItem('prd_conversation', JSON.stringify(conversation));
            } catch (e) {
                console.error('Failed to save conversation:', e);
                showStatus(status, 'Warning: Could not save conversation to browser storage', 'error');
            }
        }

        // Add message to conversation
        function addMessage(role, content) {
            conversation.push({ role, content });
            saveConversation();
            if (role !== 'system') {
                displayMessage(content, role === 'user');
            }
        }

        // Display message in UI
      function displayMessage(text, isUser) {
          const messageContainer = document.createElement('div');
          messageContainer.className = `flex items-start ${isUser ? 'justify-end' : ''}`;
  
          // Enhanced Markdown to HTML conversion for AI responses
          let formattedText = text;
          if (!isUser) {
               formattedText = formattedText
                  .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                  .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
                  .replace(/^- (.*)/gm, '<li>$1</li>') // List items
                  .replace(/`([^`]+)`/g, '<code class="bg-gray-100 px-1 rounded">$1</code>') // Inline code
                  .replace(/\n\n/g, '</p><p>') // Double line breaks become paragraph breaks
                  .replace(/\n/g, '<br>'); // Single line breaks become <br>
               
               // Wrap in paragraph tags if not already wrapped
               if (!formattedText.startsWith('<p>')) {
                   formattedText = `<p>${formattedText}</p>`;
               }
               
               // Handle lists
               if (formattedText.includes('<li>')) {
                    formattedText = formattedText.replace(/<p>(<li>.*?)<\/p>/gs, '<ul class="list-disc list-inside mb-2">$1</ul>');
               }
          }
  
            if (!isUser) {
          const avatar = document.createElement('div');
                avatar.className = 'flex-shrink-0 w-8 h-8 rounded-full bg-explo-blue flex items-center justify-center text-white text-sm font-bold mr-3';
                avatar.textContent = 'AI';
                messageContainer.appendChild(avatar);
            }
  
          const messageBubble = document.createElement('div');
            messageBubble.className = `p-3 rounded-xl max-w-[80%] ${isUser ? 'bg-explo-blue text-white ml-auto' : 'bg-gray-200 text-gray-800'}`;
          messageBubble.innerHTML = `<div class="text-sm message-content">${formattedText}</div>`;
  
          if (isUser) {
                const userAvatar = document.createElement('div');
                userAvatar.className = 'flex-shrink-0 w-8 h-8 rounded-full bg-gray-400 flex items-center justify-center text-white text-sm font-bold ml-3';
                userAvatar.textContent = 'U';
              messageContainer.appendChild(messageBubble);
              messageContainer.appendChild(userAvatar);
          } else {
              messageContainer.appendChild(messageBubble);
          }

          chatWindow.appendChild(messageContainer);
            scrollToBottom();
        }

        // Render entire conversation
        function renderConversation() {
            chatWindow.innerHTML = '';
            conversation.forEach(msg => {
                if (msg.role !== 'system') {
                    displayMessage(msg.content, msg.role === 'user');
                }
            });
        }

        // Show status message
        function showStatus(element, message, type, showSpinner = false) {
            const statusClasses = {
                'success': 'text-green-600',
                'error': 'text-red-600',
                'info': 'text-blue-600'
            };
            element.className = `text-sm ${statusClasses[type] || 'text-gray-600'}`;
            element.innerHTML = showSpinner ? `${message}<span class="spinner"></span>` : message;
        }

        // Send message to AI
        async function sendMessage(messageText) {
            if (!messageText.trim()) return;

            // Add user message
            addMessage('user', messageText);
            chatInput.value = '';
            autoResizeTextarea(); // Reset textarea height
            
            // Increment message counter for optimization
            addTokens(estimateTokens(messageText));
            
            // Show loading state
            sendChatBtn.disabled = true;
            chatSpinner.classList.remove('hidden');
            showStatus(chatStatus, 'Thinking...', 'info', true);

            try {
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ conversation })
                });

                const result = await response.json();
                
                if (response.ok && result.response) {
                    // Track actual token usage from API response
                    if (result.tokenUsage) {
                        addTokens(result.tokenUsage.promptTokens || 0, result.tokenUsage.completionTokens || 0);
                    } else {
                        // Fallback estimation if token data not available
                        addTokens(0, estimateTokens(result.response));
                    }
                    
                    addMessage('assistant', result.response);
                    saveConversation();
                    showStatus(chatStatus, '✓ Response received', 'success');
                    
                    // Check if optimization is needed AFTER successful AI response (silent background optimization)
                    if (totalTokens > TOKEN_LIMIT && !isOptimizing) {
                        console.log('Token limit exceeded, scheduling background optimization...');
                        // Schedule optimization for 2 seconds after AI response to be seamless
                        setTimeout(() => {
                            if (totalTokens > TOKEN_LIMIT && !isOptimizing) {
                                console.log('Starting silent background optimization...');
                                optimizeConversationSilently();
                            }
                        }, 2000);
                    }
                } else {
                    throw new Error(result.error || 'Chat request failed');
                }

          } catch (error) {
                console.error('Chat error:', error);
                showStatus(chatStatus, `Error: ${error.message}`, 'error');
                displayMessage("Sorry, I encountered an error. Please try again.", false);
          } finally {
                sendChatBtn.disabled = false;
                chatSpinner.classList.add('hidden');
            }
        }

        // Silent token optimization function (background, no user notification)
        async function optimizeConversationSilently() {
            if (isOptimizing) return;
            
            isOptimizing = true;
            try {
                console.log('Silent optimization: Analyzing conversation and extracting PRD information...');
                
                const response = await fetch('/optimize', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        conversation: conversation,
                        totalTokens: totalTokens 
                    })
              });
  
              const result = await response.json();
                
                if (response.ok && result.optimizedConversation) {
                    // Replace conversation with optimized version
                    conversation = result.optimizedConversation;
                    saveConversation();
                    
                    // Reset token counter after optimization
                    totalTokens = 0;
                    
                    // Log optimization results silently (no user notification)
                    console.log(`✓ Silent optimization complete: Reduced from ${result.originalTokens} to ${result.optimizedTokens} tokens (${Math.round(((result.originalTokens - result.optimizedTokens) / result.originalTokens) * 100)}% reduction)`);
                    
                    // NO user-visible message - optimization happens silently in background
                    
              } else {
                    console.error('Silent optimization failed:', result.error || 'Optimization failed');
              }

          } catch (error) {
                console.error('Silent optimization error:', error);
                // No user notification for background optimization errors
          } finally {
                isOptimizing = false;
            }
        }

        // Legacy optimization function (kept for any manual calls, but now also silent)
        async function optimizeConversation() {
            return optimizeConversationSilently();
        }

        // Progress bar stages
        const progressStages = [
            { text: "Analyzing conversation history...", percent: 15 },
            { text: "Extracting key product insights...", percent: 30 },
            { text: "Structuring PRD sections...", percent: 50 },
            { text: "Generating detailed content...", percent: 75 },
            { text: "Formatting document...", percent: 90 },
            { text: "Finalizing download...", percent: 99 }
        ];
        let progressInterval = null;
        let currentStage = 0;
        let progressActive = false;

        const progressBarBlock = document.getElementById('progressBarBlock');
        const progressBar = document.getElementById('progressBar');
        const progressStage = document.getElementById('progressStage');
        const progressPercent = document.getElementById('progressPercent');

        function showProgressBar() {
            progressBarBlock.classList.remove('hidden');
            progressBarBlock.style.display = 'block';
            progressBar.style.width = '0%';
            progressPercent.textContent = '0%';
            progressStage.textContent = progressStages[0].text;
            currentStage = 0;
            progressActive = true;
            progressBar.classList.remove('bg-red-600');
            progressBar.classList.add('bg-explo-blue');
            progressInterval = setInterval(() => {
                if (!progressActive) return;
                if (currentStage < progressStages.length) {
                    progressBar.style.width = progressStages[currentStage].percent + '%';
                    progressPercent.textContent = progressStages[currentStage].percent + '%';
                    progressStage.textContent = progressStages[currentStage].text;
                    currentStage++;
                }
            }, 3600); // 3x slower: 1200ms -> 3600ms
        }

        function completeProgressBar() {
            progressActive = false;
            clearInterval(progressInterval);
            progressBar.style.width = '100%';
            progressPercent.textContent = '100%';
            progressStage.textContent = 'Export complete!';
            setTimeout(() => {
                progressBarBlock.classList.add('hidden');
            }, 1200);
        }

        function errorProgressBar(errorMessage = 'Export failed. Please try again.') {
            progressActive = false;
            clearInterval(progressInterval);
            progressBar.style.width = '100%';
            progressBar.classList.remove('bg-explo-blue');
            progressBar.classList.add('bg-red-600');
            progressPercent.textContent = 'Error';
            progressStage.textContent = errorMessage;
            setTimeout(() => {
                progressBarBlock.classList.add('hidden');
            }, 3000); // Show error longer so user can read it
        }

        // Export PRD
        async function exportPRD() {
            if (conversation.length <= 1) {
                showStatus(status, 'Please have a conversation first before exporting', 'error');
              return;
          }

          exportPrdBtn.disabled = true;
            exportSpinner.classList.remove('hidden');
            sendChatBtn.disabled = true;
            showStatus(status, 'Generating PRD...', 'info', true);
            showProgressBar();

            try {
                const response = await fetch('/export', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ conversation })
              });
  
              const result = await response.json();
                
              if (response.ok && result.downloadURL) {
                    showStatus(status, 'PRD ready for download!', 'success');
                    completeProgressBar();
                    // Trigger download
                  const a = document.createElement('a');
                  a.href = result.downloadURL;
                  a.download = `Explo_PRD_${new Date().toISOString().slice(0, 10)}.docx`;
                  document.body.appendChild(a);
                  a.click();
                  document.body.removeChild(a);
                    // Show fallback download link after 2 seconds
                    setTimeout(() => {
                        showStatus(status, `PRD generated! <a href="${result.downloadURL}" download="${`Explo_PRD_${new Date().toISOString().slice(0, 10)}.docx`}" class="text-blue-600 hover:underline font-medium">Click here if download didn't start</a>`, 'success');
                    }, 2000);
              } else {
                    // Enhanced error handling with specific messages
                    let errorMessage = 'Export failed. Please try again.';
                    if (result.error) {
                        if (result.error.includes('API key')) {
                            errorMessage = 'Configuration error: OpenAI API key not set up. Please contact support.';
                        } else if (result.error.includes('timeout')) {
                            errorMessage = 'Request timed out. Please try again with a shorter conversation.';
                        } else if (result.error.includes('storage')) {
                            errorMessage = 'File storage error. Please try again in a few moments.';
                        } else if (result.error.includes('Failed to connect')) {
                            errorMessage = 'Network error. Please check your connection and try again.';
                        } else {
                            errorMessage = `Export failed: ${result.error}`;
                        }
                    }
                    errorProgressBar(errorMessage);
                    throw new Error(result.error || 'Failed to generate PRD');
              }

          } catch (error) {
                console.error('Export error:', error);
                let userErrorMessage = 'Export failed. Please try again.';
                
                // Provide specific error messages based on error type
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    userErrorMessage = 'Network error: Unable to connect to the server. Please check your internet connection.';
                } else if (error.message.includes('timeout')) {
                    userErrorMessage = 'Request timed out. The export is taking longer than expected. Please try again.';
                } else if (error.message.includes('API')) {
                    userErrorMessage = 'Service temporarily unavailable. Please try again in a few minutes.';
                } else if (error.message.includes('storage') || error.message.includes('file')) {
                    userErrorMessage = 'File processing error. Please try again with a shorter conversation.';
                } else {
                    userErrorMessage = `Export error: ${error.message}`;
                }
                
                errorProgressBar(userErrorMessage);
                showStatus(status, userErrorMessage, 'error');
          } finally {
              exportPrdBtn.disabled = false;
                exportSpinner.classList.add('hidden');
              sendChatBtn.disabled = false;
            }
        }

        // Clear conversation
        function clearConversation() {
            if (confirm('Are you sure you want to clear the entire conversation? This cannot be undone.')) {
                conversation = [conversation[0]]; // Keep only system message
                saveConversation();
                chatWindow.innerHTML = '';
                addMessage('assistant', "Hello! I'm your PRD Assistant. Tell me about your product idea and I'll help you build a comprehensive Product Requirements Document. What would you like to create?");
                showStatus(status, 'Conversation cleared', 'success');
            }
        }

        // Event Listeners
        chatInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage(chatInput.value);
            }
        });

        chatInput.addEventListener('input', autoResizeTextarea);

        sendChatBtn.addEventListener('click', () => {
            sendMessage(chatInput.value);
        });

        exportPrdBtn.addEventListener('click', exportPRD);
        clearChatBtn.addEventListener('click', clearConversation);

        // Initialize app
        window.onload = () => {
            loadConversation();
            showStatus(status, 'Ready to chat!', 'success');
            autoResizeTextarea(); // Initialize textarea height
        };
  </script>
</body>
</html>