<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PRD Writer | Explo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'DM Sans', sans-serif;
            background-color: #F5F5F5; /* Light Grey from Explo.co */
            color: #333333; /* Dark text color */
        }
        /* Custom Tailwind colors matching Explo.co */
        .bg-explo-blue { background-color: #0000FF; } /* Explo Blue */
        .bg-explo-darkblue { background-color: #000080; } /* Dark Blue/Navy */
        .text-explo-blue { color: #0000FF; }
        .border-explo-blue { border-color: #0000FF; }
        .ring-explo-blue { --tw-ring-color: #0000FF; }
        /* Simple spinner for loading states */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #0000FF; /* Explo Blue */
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 8px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Auto-resize textarea */
        .auto-resize {
            resize: none;
            overflow: hidden;
        }
        /* Progress bar moving lines animation */
        .progress-bar-container {
            position: relative;
            overflow: hidden;
        }
        .progress-bar-moving-lines {
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: moveLines 2s linear infinite;
        }
        @keyframes moveLines {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        /* Message formatting */
        .message-content {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .message-content p {
            margin-bottom: 0.5rem;
        }
        .message-content p:last-child {
            margin-bottom: 0;
        }

        /* Streaming indicators */
        .streaming-content {
            position: relative;
        }

        /* Smooth text appearance */
        .message-content {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Streaming status indicator */
        .streaming-status {
            color: #0000FF;
            font-style: italic;
            font-size: 0.875rem;
        }


    </style>
</head>
<body class="min-h-screen flex flex-col overflow-hidden">
                    <main class="flex-1 container mx-auto p-4 md:p-8 pb-4 flex flex-col lg:flex-row gap-8 lg:items-stretch overflow-hidden">
        <!-- PRD Assistant Sidebar -->
        <div id="leftPanel" class="lg:w-1/3 bg-white p-6 rounded-lg shadow-md flex flex-col overflow-hidden">
            <div class="flex flex-col space-y-4 overflow-y-auto flex-1">
                <!-- Top content -->
                <div class="flex flex-col space-y-4 flex-shrink-0">
                <h2 class="text-lg font-bold">Free PRD AI</h2>
                <p class="text-sm text-gray-600">Unlimited Free Chat with AI to build your Product Requirements Document. Conversation is saved locally in your browser.</p>
                
                    <div id="status" class="text-sm text-gray-600"></div>
                    
                    <div class="bg-blue-50 p-3 rounded-lg">
                    <h4 class="font-semibold text-blue-800 text-sm">Example Prompts:</h4>
                    <ul class="text-sm text-blue-700 mt-1.5 space-y-1">
                        <li>"Help me structure a PRD for a mobile app"</li>
                        <li>"What user stories should I include?"</li>
                        <li>"Define technical requirements for my product"</li>
                    </ul>
                </div>

                    <!-- Action buttons -->
                    <div class="flex flex-col space-y-3">
                <button id="clearChatBtn" class="px-4 py-2 bg-gray-500 text-white font-medium rounded-full shadow-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75">
                    Clear Conversation
                </button>
                
                        <button id="exportPrdBtn" class="px-4 py-2 bg-green-500 text-white font-medium rounded-full shadow-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-75 disabled:opacity-50">
                    Export Generated PRD
                    <span id="exportSpinner" class="spinner hidden"></span>
                </button>
                    </div>
                </div>

                <!-- Progress Bar - Now relative positioned to stay in container -->
                <div id="progressBarBlock" class="relative hidden mt-3 flex-shrink-0">
                    <div class="bg-white rounded-lg shadow-lg p-3 flex flex-col items-center border border-gray-200">
                        <div id="progressStage" class="mb-2 text-sm font-medium text-explo-blue">Exporting PRD...</div>
                        <div class="w-full bg-gray-200 rounded-full h-3 mb-2 progress-bar-container">
                            <div id="progressBar" class="bg-explo-blue h-3 rounded-full transition-all duration-500 relative" style="width: 0%">
                                <div class="progress-bar-moving-lines"></div>
                            </div>
                        </div>
                        <div id="progressPercent" class="text-xs text-gray-700">0%</div>
                    </div>
                    </div>
                </div>
            </div>
            
        <!-- Chat Area -->
        <div id="chatContainer" class="lg:w-2/3 bg-white rounded-lg shadow-md flex flex-col">
            <!-- Intro State -->
            <div id="introState" class="flex flex-col p-6 h-full" style="justify-content: center; transform: translateY(-10%);">
                <!-- Centered content container -->
                <div class="text-center max-w-4xl mx-auto">
                    <!-- Title and description positioned above center -->
                    <div class="mb-8">
                        <h1 class="text-4xl font-bold text-gray-800 mb-6">Hi, I'm your PRD Assistant</h1>
                        <p class="text-gray-600 text-xl">I'll help you build a comprehensive Product Requirements Document. Tell me about your product idea and let's get started!</p>
            </div>
                    
                    <!-- Input positioned slightly below center -->
                    <div class="flex items-center space-x-3 w-full max-w-4xl mx-auto">
                        <textarea id="chatInput" placeholder="Start typing to continue" class="flex-grow p-4 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-explo-blue auto-resize min-h-[56px] max-h-32 text-base"></textarea>
                        <button id="sendChatBtn" class="px-6 py-4 bg-explo-blue text-white font-semibold rounded-xl shadow-md hover:bg-explo-darkblue focus:outline-none focus:ring-2 focus:ring-explo-blue focus:ring-opacity-75">
                    Send
                    <span id="chatSpinner" class="spinner hidden"></span>
                </button>
            </div>
                    <div id="chatStatus" class="text-sm text-gray-600 mt-3"></div>
            </div>
        </div>

            <!-- Chat State (hidden initially) -->
            <div id="chatState" class="p-6 flex-col w-full hidden h-full">
                <div id="chatWindow" class="flex-1 overflow-y-auto border border-gray-200 rounded-lg p-4 space-y-4 bg-gray-50 mb-4">
                <!-- Messages will be added here dynamically -->
            </div>
                <div class="flex-shrink-0 flex items-end space-x-3">
                    <textarea id="chatInputChat" placeholder="Continue your conversation..." class="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-explo-blue auto-resize min-h-[48px] max-h-32"></textarea>
                    <button id="sendChatBtnChat" class="px-5 py-3 bg-explo-blue text-white font-semibold rounded-full shadow-md hover:bg-explo-darkblue focus:outline-none focus:ring-2 focus:ring-explo-blue focus:ring-opacity-75">
                        Send
                        <span id="chatSpinnerChat" class="spinner hidden"></span>
                </button>
            </div>
                <div id="chatStatusChat" class="text-sm text-gray-600 mt-2"></div>
            </div>
        </div>
    </main>


    <script>
        // Simplified conversation management using localStorage
        let conversation = [
            {
                role: 'system', 
                content: 'You are an expert Product Manager AI assistant designed to help users build Product Requirements Documents (PRDs). Your primary goal is to help users think through their product ideas and guide them through creating comprehensive PRDs. Guidelines: Ask clarifying questions to help users define their product vision. Guide them through key PRD sections: Goals, User Stories, Features, Technical Requirements, etc. Provide structured, actionable advice. Help them think about scope, timeline, and priorities. Maintain a professional, clear, and action-oriented tone. Make sure to end each answer with a question to continue the conversation.'
            }
        ];
        
        // Token optimization system
        let totalTokens = 0;
        const TOKEN_LIMIT = 3000; // Optimize every 3000 tokens
        let isOptimizing = false;
        
        // Token estimation function (rough approximation)
        function estimateTokens(text) {
            // GPT-3.5/4 uses ~4 chars per token on average
            return Math.ceil(text.length / 4);
        }
        
        // Add tokens to counter
        function addTokens(inputTokens, outputTokens = 0) {
            totalTokens += inputTokens + outputTokens;
            console.log(`Token usage: +${inputTokens + outputTokens} tokens (Total: ${totalTokens}/${TOKEN_LIMIT})`);
        }

        // UI Elements
      const chatWindow = document.getElementById('chatWindow');
      const chatInput = document.getElementById('chatInput');
      const sendChatBtn = document.getElementById('sendChatBtn');
      const exportPrdBtn = document.getElementById('exportPrdBtn');
        const clearChatBtn = document.getElementById('clearChatBtn');
      const chatStatus = document.getElementById('chatStatus');
        const status = document.getElementById('status');
      const chatSpinner = document.getElementById('chatSpinner');
      const exportSpinner = document.getElementById('exportSpinner');
  
        // Auto-resize textarea
        function autoResizeTextarea(element = null) {
            const textarea = element || this.target || chatInput;
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 128) + 'px';
        }

        // Auto-scroll chat window to bottom
        function scrollToBottom() {
            // Use multiple timeouts to ensure content is fully rendered
            setTimeout(() => {
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }, 50);
            setTimeout(() => {
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }, 150);
            setTimeout(() => {
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }, 300);
        }

        // Load conversation from localStorage on page load
        function loadConversation() {
            const saved = localStorage.getItem('prd_conversation');
            if (saved) {
                try {
                    const parsedConversation = JSON.parse(saved);
                    
                    // Validate conversation structure and remove duplicates
                    if (Array.isArray(parsedConversation) && parsedConversation.length > 0) {
                        // Remove duplicate consecutive messages
                        const uniqueConversation = [parsedConversation[0]]; // Keep system message
                        for (let i = 1; i < parsedConversation.length; i++) {
                            const current = parsedConversation[i];
                            const previous = parsedConversation[i - 1];
                            
                            // Only add if it's different from the previous message
                            if (current.content !== previous.content || current.role !== previous.role) {
                                uniqueConversation.push(current);
                            }
                        }
                        
                        conversation = uniqueConversation;
                    showStatus(status, 'Conversation loaded from browser storage', 'success');
                    } else {
                        throw new Error('Invalid conversation format');
                    }
                } catch (e) {
                    console.error('Failed to load conversation:', e);
                    showStatus(status, 'Failed to load saved conversation, starting fresh', 'error');
                    // Reset to default conversation
                    conversation = [{
                        role: 'system',
                        content: 'You are a Product Requirements Document (PRD) AI assistant. Help users create comprehensive PRDs by asking clarifying questions and providing structured guidance on product features, user stories, technical requirements, and success metrics. Make sure to end each answer with a question to continue the conversation.'
                    }];
                    // Clear corrupted data
                    localStorage.removeItem('prd_conversation');
                }
                  } else {
                // No saved conversation - start fresh
                conversation = [{
                    role: 'system',
                    content: 'You are a Product Requirements Document (PRD) AI assistant. Help users create comprehensive PRDs by asking clarifying questions and providing structured guidance on product features, user stories, technical requirements, and success metrics.'
                }];
            }
        }

        // Save conversation to localStorage
        function saveConversation() {
            try {
                localStorage.setItem('prd_conversation', JSON.stringify(conversation));
            } catch (e) {
                console.error('Failed to save conversation:', e);
                showStatus(status, 'Warning: Could not save conversation to browser storage', 'error');
            }
        }

        // Add message to conversation
        function addMessage(role, content) {
            conversation.push({ role, content });
            saveConversation();
            if (role !== 'system') {
                displayMessage(content, role === 'user');
            }
        }

        // Display message in UI
      function displayMessage(text, isUser) {
          // Switch from intro to chat mode on first message
          if (conversation.length <= 2) { // System message + first user message
              switchToChatMode();
          }

          const messageContainer = document.createElement('div');
          messageContainer.className = `flex items-start ${isUser ? 'justify-end' : ''}`;
  
          // Enhanced Markdown to HTML conversion for AI responses
          let formattedText = text;
          if (!isUser) {
               formattedText = formattedText
                  .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                  .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
                  .replace(/^- (.*)/gm, '<li>$1</li>') // List items
                  .replace(/`([^`]+)`/g, '<code class="bg-gray-100 px-1 rounded">$1</code>') // Inline code
                  .replace(/\n\n/g, '</p><p>') // Double line breaks become paragraph breaks
                  .replace(/\n/g, '<br>'); // Single line breaks become <br>
               
               // Wrap in paragraph tags if not already wrapped
               if (!formattedText.startsWith('<p>')) {
                   formattedText = `<p>${formattedText}</p>`;
               }
               
               // Handle lists
               if (formattedText.includes('<li>')) {
                    formattedText = formattedText.replace(/<p>(<li>.*?)<\/p>/gs, '<ul class="list-disc list-inside mb-2">$1</ul>');
               }
          }
  
            if (!isUser) {
          const avatar = document.createElement('div');
                avatar.className = 'flex-shrink-0 w-8 h-8 rounded-full bg-explo-blue flex items-center justify-center text-white text-sm font-bold mr-3';
                avatar.textContent = 'AI';
                messageContainer.appendChild(avatar);
            }
  
          const messageBubble = document.createElement('div');
            messageBubble.className = `p-3 rounded-xl max-w-[80%] ${isUser ? 'bg-explo-blue text-white ml-auto' : 'bg-gray-200 text-gray-800'}`;
          messageBubble.innerHTML = `<div class="text-sm message-content">${formattedText}</div>`;
  
          if (isUser) {
                const userAvatar = document.createElement('div');
                userAvatar.className = 'flex-shrink-0 w-8 h-8 rounded-full bg-gray-400 flex items-center justify-center text-white text-sm font-bold ml-3';
                userAvatar.textContent = 'U';
              messageContainer.appendChild(messageBubble);
              messageContainer.appendChild(userAvatar);
          } else {
              messageContainer.appendChild(messageBubble);
          }

          chatWindow.appendChild(messageContainer);
            scrollToBottom();
        }

        // Render entire conversation (deprecated - use initializeChatInterface instead)
        function renderConversation() {
            // This function is deprecated to prevent rendering glitches
            // Use initializeChatInterface() instead
            console.warn('renderConversation() is deprecated');
        }

        // Show status message
        function showStatus(element, message, type, showSpinner = false) {
            const statusClasses = {
                'success': 'text-green-600',
                'error': 'text-red-600',
                'info': 'text-blue-600'
            };
            element.className = `text-sm ${statusClasses[type] || 'text-gray-600'}`;
            element.innerHTML = showSpinner ? `${message}<span class="spinner"></span>` : message;
        }

        // Streaming support detection
        function detectStreamingSupport() {
            try {
                return !!(window.ReadableStream && 
                         window.Response && 
                         window.Response.prototype.body &&
                         window.TextDecoder);
            } catch (e) {
                return false;
            }
        }

        const streamingSupported = true;
        console.log('Streaming support:', streamingSupported ? 'Available' : 'Not available');

        // Enhanced message display with streaming support
        function displayStreamingMessage(isUser = false) {
            // Switch from intro to chat mode on first message
            if (conversation.length <= 2) { // System message + first user message
                switchToChatMode();
            }

            const messageContainer = document.createElement('div');
            messageContainer.className = `flex items-start ${isUser ? 'justify-end' : ''}`;

            if (!isUser) {
                const avatar = document.createElement('div');
                avatar.className = 'flex-shrink-0 w-8 h-8 rounded-full bg-explo-blue flex items-center justify-center text-white text-sm font-bold mr-3';
                avatar.textContent = 'AI';
                messageContainer.appendChild(avatar);
            }

            const messageBubble = document.createElement('div');
            messageBubble.className = `p-3 rounded-xl max-w-[80%] ${isUser ? 'bg-explo-blue text-white ml-auto' : 'bg-gray-200 text-gray-800'}`;
            messageBubble.innerHTML = `<div class="text-sm message-content streaming-content"></div>`;

            if (isUser) {
                const userAvatar = document.createElement('div');
                userAvatar.className = 'flex-shrink-0 w-8 h-8 rounded-full bg-gray-400 flex items-center justify-center text-white text-sm font-bold ml-3';
                userAvatar.textContent = 'U';
                messageContainer.appendChild(messageBubble);
                messageContainer.appendChild(userAvatar);
            } else {
                messageContainer.appendChild(messageBubble);
            }

            chatWindow.appendChild(messageContainer);
            scrollToBottom();
            
            return messageBubble.querySelector('.streaming-content');
        }

        // Enhanced markdown formatting function
        function formatMarkdown(text) {
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/^- (.*)/gm, '<li>$1</li>')
                .replace(/`([^`]+)`/g, '<code class="bg-gray-100 px-1 rounded">$1</code>')
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n/g, '<br>')
                .replace(/^(?!<p>)/, '<p>')
                .replace(/(?!<\/p>)$/, '</p>')
                .replace(/<p>(<li>.*?)<\/p>/gs, '<ul class="list-disc list-inside mb-2">$1</ul>');
        }

        // Helper function to clear active input and manage UI state
        function clearActiveInput() {
            const introState = document.getElementById('introState');
            const chatState = document.getElementById('chatState');
            
            if (!introState.classList.contains('hidden')) {
                // In intro mode
                chatInput.value = '';
                autoResizeTextarea(chatInput);
                sendChatBtn.disabled = true;
                document.getElementById('chatSpinner').classList.remove('hidden');
                showStatus(document.getElementById('chatStatus'), 'Thinking...', 'info', true);
            } else {
                // In chat mode
                chatInputChat.value = '';
                autoResizeTextarea(chatInputChat);
                sendChatBtnChat.disabled = true;
                document.getElementById('chatSpinnerChat').classList.remove('hidden');
                showStatus(document.getElementById('chatStatusChat'), 'Thinking...', 'info', true);
            }
        }

        // Helper function to reset UI state
        function resetUIState() {
            sendChatBtn.disabled = false;
            sendChatBtnChat.disabled = false;
            document.getElementById('chatSpinner').classList.add('hidden');
            document.getElementById('chatSpinnerChat').classList.add('hidden');
        }

        // Helper function to get active status element
        function getActiveStatusElement() {
            return document.getElementById('introState').classList.contains('hidden') ? 
                document.getElementById('chatStatusChat') : document.getElementById('chatStatus');
        }

        // Streaming message sender
        async function sendStreamingMessage(messageText) {
            if (!messageText.trim()) return;

            // Add user message
            addMessage('user', messageText);
            clearActiveInput();
            
            addTokens(estimateTokens(messageText));
            
            // Create streaming AI message container
            const streamingContent = displayStreamingMessage(false);
            let fullResponse = '';

            try {
                const response = await fetch('https://chat-prd-streaming-142797649545.us-central1.run.app/chat/stream', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'text/event-stream'
                    },
                    body: JSON.stringify({ conversation })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                showStatus(getActiveStatusElement(), 'Receiving response...', 'info');

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            
                            if (data === '[DONE]') {
                                break;
                            }

                            try {
                                const parsed = JSON.parse(data);
                                
                                if (parsed.type === 'chunk') {
                                    fullResponse += parsed.content;
                                    
                                    // Format and display streaming content
                                    const formattedText = formatMarkdown(fullResponse);
                                    streamingContent.innerHTML = formattedText;
                                    scrollToBottom();
                                    addBlinkingCursor(streamingContent);
                                } else if (parsed.type === 'complete') {
                                    fullResponse = parsed.content;
                                    const formattedText = formatMarkdown(fullResponse);
                                    streamingContent.innerHTML = formattedText;
                                    
                                    // Mark streaming as complete and remove cursor
                                    removeBlinkingCursor(streamingContent);
                                } else if (parsed.type === 'error') {
                                    throw new Error(parsed.content);
                                }
                            } catch (parseError) {
                                console.warn('Could not parse SSE data:', data);
                            }
                        }
                    }
                }

                // Remove cursor when streaming is done
                removeBlinkingCursor(streamingContent);
                
                // Add to conversation history
                conversation.push({ role: 'assistant', content: fullResponse });
                saveConversation();
                addTokens(0, estimateTokens(fullResponse));
                showStatus(getActiveStatusElement(), '✓ Response received', 'success');

                // Check for optimization
                if (totalTokens > TOKEN_LIMIT && !isOptimizing) {
                    setTimeout(() => {
                        if (totalTokens > TOKEN_LIMIT && !isOptimizing) {
                            optimizeConversationSilently();
                        }
                    }, 2000);
                }

                // Analytics tracking AFTER all core functionality (non-blocking)
                setTimeout(() => Analytics.trackChatMessage(false, fullResponse.length), 0);

            } catch (error) {
                console.error('Streaming error:', error);
                
                // Remove cursor from failed streaming message before removing it
                removeBlinkingCursor(streamingContent);
                
                // Remove failed streaming message
                streamingContent.parentElement.parentElement.remove();
                
                // Fallback to non-streaming
                console.log('Falling back to non-streaming...');
                return sendFallbackMessage(messageText);
            } finally {
                resetUIState();
            }
        }

        // Fallback non-streaming message sender
        async function sendFallbackMessage(messageText) {
            showStatus(getActiveStatusElement(), 'Using fallback mode...', 'info');
            
            try {
                const response = await fetch('https://chat-prd-streaming-142797649545.us-central1.run.app/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ conversation })
                });

                const result = await response.json();
                
                if (response.ok && result.response) {
                    addMessage('assistant', result.response);
                    if (result.tokenUsage) {
                        addTokens(result.tokenUsage.promptTokens || 0, result.tokenUsage.completionTokens || 0);
                    } else {
                        addTokens(0, estimateTokens(result.response));
                    }
                    showStatus(getActiveStatusElement(), '✓ Response received (fallback)', 'success');
                    
                    // Check for optimization
                    if (totalTokens > TOKEN_LIMIT && !isOptimizing) {
                        setTimeout(() => {
                            if (totalTokens > TOKEN_LIMIT && !isOptimizing) {
                                optimizeConversationSilently();
                            }
                        }, 2000);
                    }
                } else {
                    throw new Error(result.error || 'Fallback request failed');
                }
            } catch (fallbackError) {
                console.error('Fallback also failed:', fallbackError);
                showStatus(getActiveStatusElement(), `Error: ${fallbackError.message}`, 'error');
                displayMessage("Sorry, I encountered an error. Please try again.", false);
            }
        }

        // Main send message function with progressive enhancement
        async function sendMessage(messageText) {
            if (!messageText.trim()) return;

            // Execute core functionality FIRST, analytics AFTER
            const isFirstMessage = conversation.length <= 1; // Calculate this early
            
            let result;
            if (streamingSupported) {
                try {
                    result = await sendStreamingMessage(messageText);
          } catch (error) {
                    console.warn('Streaming failed, using fallback:', error);
                    // Queue error tracking for later (non-blocking)
                    setTimeout(() => Analytics.trackError('streaming_failed', error.message), 0);
                    result = await sendFallbackMessage(messageText);
                }
            } else {
                console.log('Using non-streaming mode for compatibility');
                result = await sendFallbackMessage(messageText);
            }

            // Analytics tracking AFTER core functionality completes (non-blocking)
            setTimeout(() => {
                try {
                    if (isFirstMessage) {
                        Analytics.trackChatStart();
                }
                Analytics.trackChatMessage(true, messageText.length);
            } catch (error) {
                // Silent failure to avoid any impact
            }
        }, 0);
            
            return result;
        }

        // Silent token optimization function (background, no user notification)
        async function optimizeConversationSilently() {
            if (isOptimizing) return;
            
            isOptimizing = true;
            try {
                console.log('Silent optimization: Analyzing conversation and extracting PRD information...');
                
                const response = await fetch('https://chat-prd-streaming-142797649545.us-central1.run.app/optimize', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        conversation: conversation,
                        totalTokens: totalTokens 
                    })
              });
  
              const result = await response.json();
                
                if (response.ok && result.optimizedConversation) {
                    // Replace conversation with optimized version
                    conversation = result.optimizedConversation;
                    saveConversation();
                    
                    // Reset token counter after optimization
                    totalTokens = 0;
                    
                    // Log optimization results silently (no user notification)
                    console.log(`✓ Silent optimization complete: Reduced from ${result.originalTokens} to ${result.optimizedTokens} tokens (${Math.round(((result.originalTokens - result.optimizedTokens) / result.originalTokens) * 100)}% reduction)`);
                    
                    // NO user-visible message - optimization happens silently in background
                    
              } else {
                    console.error('Silent optimization failed:', result.error || 'Optimization failed');
              }

          } catch (error) {
                console.error('Silent optimization error:', error);
                // No user notification for background optimization errors
          } finally {
                isOptimizing = false;
            }
        }

        // Legacy optimization function (kept for any manual calls, but now also silent)
        async function optimizeConversation() {
            return optimizeConversationSilently();
        }

        // Progress bar stages
        const progressStages = [
            { text: "Analyzing conversation history...", percent: 15 },
            { text: "Extracting key product insights...", percent: 30 },
            { text: "Structuring PRD sections...", percent: 50 },
            { text: "Generating detailed content...", percent: 75 },
            { text: "Formatting document...", percent: 90 },
            { text: "Finalizing download...", percent: 99 }
        ];
        let progressInterval = null;
        let currentStage = 0;
        let progressActive = false;

        const progressBarBlock = document.getElementById('progressBarBlock');
        const progressBar = document.getElementById('progressBar');
        const progressStage = document.getElementById('progressStage');
        const progressPercent = document.getElementById('progressPercent');

        function showProgressBar() {
            progressBarBlock.classList.remove('hidden');
            progressBarBlock.style.display = 'block';
            progressBar.style.width = '0%';
            progressPercent.textContent = '0%';
            progressStage.textContent = progressStages[0].text;
            currentStage = 0;
            progressActive = true;
            progressBar.classList.remove('bg-red-600');
            progressBar.classList.add('bg-explo-blue');
            progressInterval = setInterval(() => {
                if (!progressActive) return;
                if (currentStage < progressStages.length) {
                    progressBar.style.width = progressStages[currentStage].percent + '%';
                    progressPercent.textContent = progressStages[currentStage].percent + '%';
                    progressStage.textContent = progressStages[currentStage].text;
                    currentStage++;
                }
            }, 3600); // 3x slower: 1200ms -> 3600ms
        }

        function completeProgressBar() {
            progressActive = false;
            clearInterval(progressInterval);
            progressBar.style.width = '100%';
            progressPercent.textContent = '100%';
            progressStage.textContent = 'Export complete!';
            setTimeout(() => {
                progressBarBlock.classList.add('hidden');
            }, 1200);
        }

        function errorProgressBar(errorMessage = 'Export failed. Please try again.') {
            progressActive = false;
            clearInterval(progressInterval);
            progressBar.style.width = '100%';
            progressBar.classList.remove('bg-explo-blue');
            progressBar.classList.add('bg-red-600');
            progressPercent.textContent = 'Error';
            progressStage.textContent = errorMessage;
            setTimeout(() => {
                progressBarBlock.classList.add('hidden');
            }, 3000); // Show error longer so user can read it
        }

        // Export PRD
        async function exportPRD() {
            if (conversation.length <= 1) {
                showStatus(status, 'Please have a conversation first before exporting', 'error');
              return;
          }

          exportPrdBtn.disabled = true;
            exportSpinner.classList.remove('hidden');
            sendChatBtn.disabled = true;
            sendChatBtnChat.disabled = true;
            showStatus(status, 'Generating PRD...', 'info', true);
            showProgressBar();

            try {
                const response = await fetch('https://chat-prd-streaming-142797649545.us-central1.run.app/export', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ conversation })
              });
  
              const result = await response.json();
                
              if (response.ok) {
                    showStatus(status, 'PRD ready for download!', 'success');
                    completeProgressBar();
                    
                    let downloadTriggered = false;
                    
                    // Handle different response formats
                    if (result.downloadURL) {
                        // Public URL download
                        const a = document.createElement('a');
                        a.href = result.downloadURL;
                        a.download = result.fileName || `Explo_PRD_${new Date().toISOString().slice(0, 10)}.docx`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        downloadTriggered = true;
                        
                        // Show fallback download link
                        setTimeout(() => {
                            showStatus(status, `PRD generated! <a href="${result.downloadURL}" download="${result.fileName || `Explo_PRD_${new Date().toISOString().slice(0, 10)}.docx`}" class="text-blue-600 hover:underline font-medium">Click here if download didn't start</a>`, 'success');
                        }, 2000);
                        
                    } else if (result.downloadData) {
                        // Base64 data download
                        const blob = new Blob([new Uint8Array(atob(result.downloadData).split('').map(c => c.charCodeAt(0)))], {
                            type: result.mimeType || 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
                        });
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = result.fileName || `Explo_PRD_${new Date().toISOString().slice(0, 10)}.docx`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                        downloadTriggered = true;
                        
                        showStatus(status, 'PRD downloaded successfully!', 'success');
                        
                    } else if (result.error) {
                        // Handle storage upload failure but file was generated
                        let errorMessage = 'PRD was generated but download failed. Please try again.';
                        if (result.error.includes('Storage upload failed')) {
                            errorMessage = 'File was generated but storage failed. Please try the export again.';
                        }
                        errorProgressBar(errorMessage);
                        throw new Error(result.error);
                    }
                    
                    // Analytics tracking AFTER download is triggered (non-blocking)
                    if (downloadTriggered) {
                        setTimeout(() => Analytics.trackPRDGenerated(), 0);
                    }
                    
              } else {
                    // Enhanced error handling with specific messages
                    let errorMessage = 'Export failed. Please try again.';
                    if (result.error) {
                        if (result.error.includes('API key')) {
                            errorMessage = 'Configuration error: OpenAI API key not set up. Please contact support.';
                        } else if (result.error.includes('timeout')) {
                            errorMessage = 'Request timed out. Please try again with a shorter conversation.';
                        } else if (result.error.includes('storage')) {
                            errorMessage = 'File storage error. Please try again in a few moments.';
                        } else if (result.error.includes('Failed to connect')) {
                            errorMessage = 'Network error. Please check your connection and try again.';
                        } else {
                            errorMessage = `Export failed: ${result.error}`;
                        }
                    }
                    errorProgressBar(errorMessage);
                    throw new Error(result.error || 'Failed to generate PRD');
              }

          } catch (error) {
                console.error('Export error:', error);
                
                let userErrorMessage = 'Export failed. Please try again.';
                
                // Queue analytics tracking for later (non-blocking)
                setTimeout(() => Analytics.trackError('export_failed', error.message), 0);
                
                errorProgressBar(userErrorMessage);
                showStatus(status, userErrorMessage, 'error');
          } finally {
              exportPrdBtn.disabled = false;
                exportSpinner.classList.add('hidden');
              sendChatBtn.disabled = false;
              sendChatBtnChat.disabled = false;
            }
        }

        // Clear conversation
        function clearConversation() {
            if (confirm('Are you sure you want to clear the entire conversation? This cannot be undone.')) {
                conversation = [conversation[0]]; // Keep only system message
                saveConversation();
                
                // Clear the chat window completely
                const chatWindow = document.getElementById('chatWindow');
                chatWindow.innerHTML = '';
                
                // Reset to intro state
                const introState = document.getElementById('introState');
                const chatState = document.getElementById('chatState');
                
                // Show intro state
                introState.classList.remove('hidden');
                introState.style.display = 'flex';
                
                // Hide chat state
                chatState.classList.add('hidden');
                chatState.style.display = 'none';
                
                // Clear both input fields
                chatInput.value = '';
                chatInputChat.value = '';
                
                showStatus(status, 'Conversation cleared', 'success');
            }
        }

        // Event Listeners
        const chatInputChat = document.getElementById('chatInputChat');
        const sendChatBtnChat = document.getElementById('sendChatBtnChat');

        // Intro input handlers
        chatInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage(chatInput.value);
            }
        });

        chatInput.addEventListener('input', autoResizeTextarea);

        sendChatBtn.addEventListener('click', () => {
            sendMessage(chatInput.value);
        });

        // Chat input handlers
        chatInputChat.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage(chatInputChat.value);
            }
        });

        chatInputChat.addEventListener('input', () => {
            autoResizeTextarea.call({ target: chatInputChat });
        });

        sendChatBtnChat.addEventListener('click', () => {
            sendMessage(chatInputChat.value);
        });

        exportPrdBtn.addEventListener('click', exportPRD);
        clearChatBtn.addEventListener('click', clearConversation);

        // Initialize chat interface state
        function initializeChatInterface() {
            const introState = document.getElementById('introState');
            const chatState = document.getElementById('chatState');
            const chatWindow = document.getElementById('chatWindow');
            
            if (conversation.length <= 1) {
                // Show intro state - no conversation exists
                introState.classList.remove('hidden');
                introState.style.display = 'flex';
                chatState.classList.add('hidden');
                chatState.style.display = 'none';
            } else {
                // Show chat state if conversation exists
                introState.classList.add('hidden');
                introState.style.display = 'none';
                chatState.classList.remove('hidden');
                chatState.style.display = 'flex';
                
                // Clear and reload existing messages (skip system message at index 0)
                chatWindow.innerHTML = '';
                for (let i = 1; i < conversation.length; i++) {
                    const message = conversation[i];
                    // Use a direct rendering function that doesn't trigger mode switching
                    renderMessageDirectly(message.content, message.role === 'user');
                }
            }
        }

        // Direct message rendering that doesn't trigger mode switching
        function renderMessageDirectly(text, isUser) {
            const chatWindow = document.getElementById('chatWindow');
            const messageContainer = document.createElement('div');
            messageContainer.className = `flex items-start ${isUser ? 'justify-end' : ''}`;
  
            // Enhanced Markdown to HTML conversion for AI responses
            let formattedText = text;
            if (!isUser) {
                formattedText = formattedText
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                    .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
                    .replace(/^- (.*)/gm, '<li>$1</li>') // List items
                    .replace(/`([^`]+)`/g, '<code class="bg-gray-100 px-1 rounded">$1</code>') // Inline code
                    .replace(/\n\n/g, '</p><p>') // Double line breaks become paragraph breaks
                    .replace(/\n/g, '<br>'); // Single line breaks become <br>
                 
                 // Wrap in paragraph tags if not already wrapped
                 if (!formattedText.startsWith('<p>')) {
                     formattedText = `<p>${formattedText}</p>`;
                 }
                 
                 // Handle lists
                 if (formattedText.includes('<li>')) {
                      formattedText = formattedText.replace(/<p>(<li>.*?)<\/p>/gs, '<ul class="list-disc list-inside mb-2">$1</ul>');
                 }
            }

            if (!isUser) {
                const avatar = document.createElement('div');
                avatar.className = 'flex-shrink-0 w-8 h-8 rounded-full bg-explo-blue flex items-center justify-center text-white text-sm font-bold mr-3';
                avatar.textContent = 'AI';
                messageContainer.appendChild(avatar);
            }

            const messageBubble = document.createElement('div');
            messageBubble.className = `p-3 rounded-xl max-w-[80%] ${isUser ? 'bg-explo-blue text-white ml-auto' : 'bg-gray-200 text-gray-800'}`;
            messageBubble.innerHTML = `<div class="text-sm message-content">${formattedText}</div>`;

            if (isUser) {
                const userAvatar = document.createElement('div');
                userAvatar.className = 'flex-shrink-0 w-8 h-8 rounded-full bg-gray-400 flex items-center justify-center text-white text-sm font-bold ml-3';
                userAvatar.textContent = 'U';
                messageContainer.appendChild(messageBubble);
                messageContainer.appendChild(userAvatar);
            } else {
                messageContainer.appendChild(messageBubble);
            }

            chatWindow.appendChild(messageContainer);
            scrollToBottom();
        }

        // Switch from intro to chat mode
        function switchToChatMode() {
            const introState = document.getElementById('introState');
            const chatState = document.getElementById('chatState');
            
            // Completely hide intro state
            introState.classList.add('hidden');
            introState.style.display = 'none';
            
            // Show chat state
            chatState.classList.remove('hidden');
            chatState.style.display = 'flex';
            
            // Auto-scroll to show the conversation area with better positioning
            setTimeout(() => {
                const chatContainer = document.getElementById('chatContainer');
                if (chatContainer) {
                    // Scroll to center the chat container instead of putting it at the top
                    chatContainer.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center' 
                    });
                }
            }, 100); // Small delay to ensure the chat state is rendered
        }

        // Initialize app
        window.onload = () => {
            try {
                Analytics.init(); // Initialize analytics (safe)
            } catch (error) {
                console.warn('Analytics initialization failed (non-critical):', error);
            }
            
            initializeDynamicHeight(); // Set up dynamic heights first
            loadConversation();
            initializeChatInterface();
            autoResizeTextarea(); // Initialize textarea height
            
            // Warm up the Cloud Run service immediately on page load
            warmUpService();
            
            // Track page view after everything is loaded
            try {
                Analytics.trackPageView();
            } catch (error) {
                console.warn('Analytics page view tracking failed (non-critical):', error);
            }
        };

        // Warm-up function to eliminate cold start delays
        async function warmUpService() {
            try {
                console.log('🔥 Warming up Cloud Run service...');
                showStatus(status, 'Initializing AI service...', 'info');
                
                const startTime = Date.now();
                
                // Call the warmup endpoint
                const response = await fetch('https://chat-prd-streaming-142797649545.us-central1.run.app/warmup', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                
                const result = await response.json();
                const totalTime = Date.now() - startTime;
                
                if (response.ok && result.status === 'warmed_up') {
                    console.log(`✅ Service warmed up in ${totalTime}ms (server: ${Math.round(result.warmup_time * 1000)}ms)`);
                    showStatus(status, '✓ AI service ready', 'success');
                    
                    // Clear status after a short delay
                    setTimeout(() => {
                        showStatus(status, '', 'info');
                    }, 2000);
                } else {
                    console.warn('⚠️ Service warmup completed with issues:', result);
                    showStatus(status, 'AI service initialized', 'info');
                    
                    // Clear status after a short delay
                    setTimeout(() => {
                        showStatus(status, '', 'info');
                    }, 3000);
                }
            } catch (error) {
                console.warn('⚠️ Service warmup failed (non-critical):', error);
                // Don't show error to user as this is a background optimization
                showStatus(status, '', 'info');
            }
        }

        // Cursor functions removed - no cursor needed for streaming
        function addBlinkingCursor(targetElem) {
            // No cursor needed
        }
        function removeBlinkingCursor(targetElem) {
            // No cursor needed
        }

        // Dynamic height calculation system
        function calculateOptimalChatHeight() {
            const viewportHeight = window.innerHeight;
            const isInIframe = window !== window.parent;
            
            // If in iframe, use more of the available space
            const headerHeight = isInIframe ? 20 : 80; // Less header space in iframe
            const footerHeight = isInIframe ? 20 : 40; // Less footer space in iframe
            
            // Responsive height configuration
            const width = window.innerWidth;
            let config;
            
            if (width < 768) {
                // Mobile
                config = { min: 350, max: 500, percentage: isInIframe ? 0.95 : 0.8 };
            } else if (width < 1024) {
                // Tablet
                config = { min: 400, max: 800, percentage: isInIframe ? 0.95 : 0.9 };
            } else {
                // Desktop
                config = { min: 500, max: 1000, percentage: isInIframe ? 0.95 : 0.9 };
            }
            
            const availableHeight = viewportHeight - headerHeight - footerHeight;
            const calculatedHeight = availableHeight * config.percentage;
            
            // Clamp between min and max
            const optimalHeight = Math.max(config.min, Math.min(config.max, calculatedHeight));
            
            return Math.floor(optimalHeight);
        }
        
        function setDynamicHeight() {
            const optimalHeight = calculateOptimalChatHeight();
            const isInIframe = window !== window.parent;
            
            // Set CSS custom property for dynamic height
            document.documentElement.style.setProperty('--dynamic-chat-height', `${optimalHeight}px`);
            
            // Apply to both panels to ensure same height
            const leftPanel = document.getElementById('leftPanel');
            const chatContainer = document.getElementById('chatContainer');
            
            if (leftPanel) {
                leftPanel.style.height = `${optimalHeight}px`;
                leftPanel.style.minHeight = `${optimalHeight}px`;
                leftPanel.style.maxHeight = `${optimalHeight}px`;
            }
            
            if (chatContainer) {
                chatContainer.style.height = `${optimalHeight}px`;
                chatContainer.style.minHeight = `${optimalHeight}px`;
                chatContainer.style.maxHeight = `${optimalHeight}px`;
            }
            
            console.log(`Dynamic height set to: ${optimalHeight}px (viewport: ${window.innerHeight}px, iframe: ${isInIframe}, width: ${window.innerWidth}px)`);
        }
        
        // Initialize dynamic height on load and resize
        function initializeDynamicHeight() {
            setDynamicHeight();
            
            // Add resize listener with debouncing
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(setDynamicHeight, 150);
            });
        }

        // Optimized Analytics System - Fully asynchronous and non-blocking
        const Analytics = {
            enabled: false,
            isInIframe: false,
            parentOrigin: 'https://explo.co',
            queue: [], // Queue analytics events to prevent blocking
            testMode: false, // Set to true for direct GA4 testing
            
            init() {
                try {
                    this.isInIframe = window !== window.parent;
                    this.enabled = this.isInIframe; // Only enable in iframe context
                    
                    // For testing: enable even when not in iframe
                    if (!this.enabled && this.testMode) {
                        this.enabled = true;
                        console.log('Analytics: Test mode enabled');
                    }
                    
                    if (this.enabled) {
                        console.log('Analytics: Initialized for iframe context');
                        // Process any queued events
                        this.processQueue();
                    }
                } catch (error) {
                    console.warn('Analytics: Initialization failed (non-critical):', error);
                    this.enabled = false;
                }
            },
            
            // Asynchronous, non-blocking track method
            track(eventName, parameters = {}) {
                if (!this.enabled) return;
                
                // Use setTimeout to make this completely asynchronous
                setTimeout(() => {
                    try {
                        const eventData = {
                            type: 'analytics_event',
                            event: eventName,
                            parameters: {
                                ...parameters,
                                iframe_source: 'prd-ai',
                                timestamp: new Date().toISOString(),
                                page: '/prd-ai'
                            }
                        };
                        
                        if (this.isInIframe) {
                            // Send to parent window for production
                            window.parent.postMessage(eventData, this.parentOrigin);
                        } else if (this.testMode && typeof gtag !== 'undefined') {
                            // Direct GA4 for testing
                            gtag('event', eventName, eventData.parameters);
                            console.log('Direct GA4 event:', eventName, eventData.parameters);
                        }
                        
                        // Minimal logging to reduce overhead
                        if (console.debug) {
                            console.debug('Analytics:', eventName);
                        }
                    } catch (error) {
                        // Silent failure - don't even log to avoid performance impact
                    }
                }, 0); // Execute on next tick to avoid blocking
            },
            
            processQueue() {
                while (this.queue.length > 0) {
                    const { eventName, parameters } = this.queue.shift();
                    this.track(eventName, parameters);
                }
            },
            
            // Queue events if analytics not ready yet
            queueEvent(eventName, parameters) {
                this.queue.push({ eventName, parameters });
            },
            
            // Optimized tracking methods - all async
            trackPageView() {
                this.track('page_view', {
                    tool: 'prd_ai',
                    viewport_height: window.innerHeight,
                    viewport_width: window.innerWidth
                });
            },
            
            trackChatStart() {
                this.track('chat_started', {
                    tool: 'prd_ai'
                });
            },
            
            trackChatMessage(isUser, messageLength) {
                this.track('chat_message', {
                    tool: 'prd_ai',
                    message_type: isUser ? 'user' : 'ai',
                    length: messageLength > 1000 ? '1000+' : messageLength < 100 ? '<100' : '100-1000' // Bucketize to reduce data
                });
            },
            
            trackPRDGenerated() {
                this.track('prd_generated', {
                    tool: 'prd_ai'
                });
            },
            
            trackError(errorType, errorMessage) {
                this.track('error_occurred', {
                    tool: 'prd_ai',
                    error_type: errorType
                    // Remove error_message to reduce payload size
                });
            }
        };
  </script>
</body>
</html>