<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PRD Writer | Explo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'DM Sans', sans-serif;
            background-color: #F5F5F5; /* Light Grey from Explo.co */
            color: #333333; /* Dark text color */
        }
        /* Custom Tailwind colors matching Explo.co */
        .bg-explo-blue { background-color: #0000FF; } /* Explo Blue */
        .bg-explo-darkblue { background-color: #000080; } /* Dark Blue/Navy */
        .text-explo-blue { color: #0000FF; }
        .border-explo-blue { border-color: #0000FF; }
        .ring-explo-blue { --tw-ring-color: #0000FF; }
        /* Simple spinner for loading states */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #0000FF; /* Explo Blue */
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 8px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Auto-resize textarea */
        .auto-resize {
            resize: none;
            overflow: hidden;
        }
        /* Progress bar moving lines animation */
        .progress-bar-container {
            position: relative;
            overflow: hidden;
        }
        .progress-bar-moving-lines {
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: moveLines 2s linear infinite;
        }
        @keyframes moveLines {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        /* Message formatting */
        .message-content {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .message-content p {
            margin-bottom: 0.5rem;
        }
        .message-content p:last-child {
            margin-bottom: 0;
        }

        /* Streaming indicators */
        .streaming-content {
            position: relative;
        }

        /* Smooth text appearance */
        .message-content {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Streaming status indicator */
        .streaming-status {
            color: #0000FF;
            font-style: italic;
            font-size: 0.875rem;
        }


    </style>
</head>
<body class="min-h-screen flex flex-col">
          <main class="flex-grow container mx-auto p-4 md:p-8 flex flex-col lg:flex-row gap-8 items-start">
          <!-- PRD Assistant Sidebar -->
        <div class="lg:w-1/3 bg-white p-6 rounded-lg shadow-md flex flex-col" style="height: fit-content;">
            <div class="flex flex-col space-y-4">
                <h2 class="text-xl font-bold">Free PRD AI</h2>
                <p class="text-gray-600">Unlimited Free Chat with AI to build your Product Requirements Document. Conversation is saved locally in your browser.</p>
                
                <div id="status" class="text-sm text-gray-600"></div>
                
                <div class="bg-blue-50 p-4 rounded-lg">
                    <h4 class="font-semibold text-blue-800">Example Prompts:</h4>
                    <ul class="text-sm text-blue-700 mt-2 space-y-1">
                        <li>"Help me structure a PRD for a mobile app"</li>
                        <li>"What user stories should I include?"</li>
                        <li>"Define technical requirements for my product"</li>
                    </ul>
                </div>

                <button id="clearChatBtn" class="px-4 py-2 bg-gray-500 text-white font-semibold rounded-full shadow-md hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75">
                    Clear Conversation
                </button>
                
                <button id="exportPrdBtn" class="px-4 py-2 bg-green-500 text-white font-semibold rounded-full shadow-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-75 disabled:opacity-50">
                    Export Generated PRD
                    <span id="exportSpinner" class="spinner hidden"></span>
                </button>

                <!-- Progress Bar - Positioned absolutely to avoid layout shifts -->
                <div id="progressBarBlock" class="absolute left-6 right-6 bottom-24 hidden z-20">
                    <div class="bg-white rounded-lg shadow-lg p-4 flex flex-col items-center border border-gray-200">
                        <div id="progressStage" class="mb-2 text-base font-semibold text-explo-blue">Exporting PRD...</div>
                        <div class="w-full bg-gray-200 rounded-full h-4 mb-2 progress-bar-container">
                            <div id="progressBar" class="bg-explo-blue h-4 rounded-full transition-all duration-500 relative" style="width: 0%">
                                <div class="progress-bar-moving-lines"></div>
                            </div>
                        </div>
                        <div id="progressPercent" class="text-sm text-gray-700">0%</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chat Area -->
        <div id="chatContainer" class="lg:w-2/3 bg-white rounded-lg shadow-md flex flex-col">
            <!-- Intro State -->
            <div id="introState" class="flex flex-col items-center justify-center p-6" style="min-height: 500px;">
                <div class="text-center max-w-2xl">
                    <h1 class="text-4xl font-bold text-gray-800 mb-6">Hi, I'm your PRD Assistant</h1>
                    <p class="text-gray-600 text-xl mb-8">I'll help you build a comprehensive Product Requirements Document. Tell me about your product idea and let's get started!</p>
                    
                    <div class="flex items-center space-x-3 max-w-3xl mx-auto">
                        <textarea id="chatInput" placeholder="Start typing to continue" class="flex-grow p-4 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-explo-blue auto-resize min-h-[56px] max-h-32 text-base"></textarea>
                        <button id="sendChatBtn" class="px-6 py-4 bg-explo-blue text-white font-semibold rounded-xl shadow-md hover:bg-explo-darkblue focus:outline-none focus:ring-2 focus:ring-explo-blue focus:ring-opacity-75">
                            Send
                            <span id="chatSpinner" class="spinner hidden"></span>
                        </button>
                    </div>
                    <div id="chatStatus" class="text-sm text-gray-600 mt-3"></div>
                </div>
            </div>

            <!-- Chat State (hidden initially) -->
            <div id="chatState" class="bg-white p-6 rounded-lg shadow-md flex-col w-full hidden">
                <div id="chatWindow" class="flex-grow overflow-y-auto border border-gray-200 rounded-lg p-4 mb-4 space-y-4 bg-gray-50 min-h-[500px]">
                    <!-- Messages will be added here dynamically -->
                </div>
                <div class="flex items-end space-x-3">
                    <textarea id="chatInputChat" placeholder="Continue your conversation..." class="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-explo-blue auto-resize min-h-[48px] max-h-32"></textarea>
                    <button id="sendChatBtnChat" class="px-5 py-3 bg-explo-blue text-white font-semibold rounded-full shadow-md hover:bg-explo-darkblue focus:outline-none focus:ring-2 focus:ring-explo-blue focus:ring-opacity-75">
                        Send
                        <span id="chatSpinnerChat" class="spinner hidden"></span>
                    </button>
                </div>
                <div id="chatStatusChat" class="text-sm text-gray-600 mt-2"></div>
            </div>
        </div>
    </main>
    <footer class="bg-explo-darkblue text-white p-4 text-center mt-8">
        <p>© 2025 Explo. All rights reserved.</p>
    </footer>

    <script>
        // Simplified conversation management using localStorage
        let conversation = [
            {
                role: 'system', 
                content: 'You are an expert Product Manager AI assistant designed to help users build Product Requirements Documents (PRDs). Your primary goal is to help users think through their product ideas and guide them through creating comprehensive PRDs. Guidelines: Ask clarifying questions to help users define their product vision. Guide them through key PRD sections: Goals, User Stories, Features, Technical Requirements, etc. Provide structured, actionable advice. Help them think about scope, timeline, and priorities. Maintain a professional, clear, and action-oriented tone.'
            }
        ];
        
        // Token optimization system
        let totalTokens = 0;
        const TOKEN_LIMIT = 3000; // Optimize every 3000 tokens
        let isOptimizing = false;
        
        // Token estimation function (rough approximation)
        function estimateTokens(text) {
            // GPT-3.5/4 uses ~4 chars per token on average
            return Math.ceil(text.length / 4);
        }
        
        // Add tokens to counter
        function addTokens(inputTokens, outputTokens = 0) {
            totalTokens += inputTokens + outputTokens;
            console.log(`Token usage: +${inputTokens + outputTokens} tokens (Total: ${totalTokens}/${TOKEN_LIMIT})`);
        }

        // UI Elements
      const chatWindow = document.getElementById('chatWindow');
      const chatInput = document.getElementById('chatInput');
      const sendChatBtn = document.getElementById('sendChatBtn');
      const exportPrdBtn = document.getElementById('exportPrdBtn');
        const clearChatBtn = document.getElementById('clearChatBtn');
      const chatStatus = document.getElementById('chatStatus');
        const status = document.getElementById('status');
      const chatSpinner = document.getElementById('chatSpinner');
      const exportSpinner = document.getElementById('exportSpinner');
  
        // Auto-resize textarea
        function autoResizeTextarea(element = null) {
            const textarea = element || this.target || chatInput;
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 128) + 'px';
        }

        // Auto-scroll chat window to bottom
        function scrollToBottom() {
            // Use multiple timeouts to ensure content is fully rendered
            setTimeout(() => {
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }, 50);
            setTimeout(() => {
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }, 150);
            setTimeout(() => {
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }, 300);
        }

        // Load conversation from localStorage on page load
        function loadConversation() {
            const saved = localStorage.getItem('prd_conversation');
            if (saved) {
                try {
                    const parsedConversation = JSON.parse(saved);
                    
                    // Validate conversation structure and remove duplicates
                    if (Array.isArray(parsedConversation) && parsedConversation.length > 0) {
                        // Remove duplicate consecutive messages
                        const uniqueConversation = [parsedConversation[0]]; // Keep system message
                        for (let i = 1; i < parsedConversation.length; i++) {
                            const current = parsedConversation[i];
                            const previous = parsedConversation[i - 1];
                            
                            // Only add if it's different from the previous message
                            if (current.content !== previous.content || current.role !== previous.role) {
                                uniqueConversation.push(current);
                            }
                        }
                        
                        conversation = uniqueConversation;
                        showStatus(status, 'Conversation loaded from browser storage', 'success');
                    } else {
                        throw new Error('Invalid conversation format');
                    }
                } catch (e) {
                    console.error('Failed to load conversation:', e);
                    showStatus(status, 'Failed to load saved conversation, starting fresh', 'error');
                    // Reset to default conversation
                    conversation = [{
                        role: 'system',
                        content: 'You are a Product Requirements Document (PRD) AI assistant. Help users create comprehensive PRDs by asking clarifying questions and providing structured guidance on product features, user stories, technical requirements, and success metrics.'
                    }];
                    // Clear corrupted data
                    localStorage.removeItem('prd_conversation');
                }
            } else {
                // No saved conversation - start fresh
                conversation = [{
                    role: 'system',
                    content: 'You are a Product Requirements Document (PRD) AI assistant. Help users create comprehensive PRDs by asking clarifying questions and providing structured guidance on product features, user stories, technical requirements, and success metrics.'
                }];
            }
        }

        // Save conversation to localStorage
        function saveConversation() {
            try {
                localStorage.setItem('prd_conversation', JSON.stringify(conversation));
            } catch (e) {
                console.error('Failed to save conversation:', e);
                showStatus(status, 'Warning: Could not save conversation to browser storage', 'error');
            }
        }

        // Add message to conversation
        function addMessage(role, content) {
            conversation.push({ role, content });
            saveConversation();
            if (role !== 'system') {
                displayMessage(content, role === 'user');
            }
        }

        // Display message in UI
      function displayMessage(text, isUser) {
          // Switch from intro to chat mode on first message
          if (conversation.length <= 2) { // System message + first user message
              switchToChatMode();
          }

          const messageContainer = document.createElement('div');
          messageContainer.className = `flex items-start ${isUser ? 'justify-end' : ''}`;
  
          // Enhanced Markdown to HTML conversion for AI responses
          let formattedText = text;
          if (!isUser) {
               formattedText = formattedText
                  .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                  .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
                  .replace(/^- (.*)/gm, '<li>$1</li>') // List items
                  .replace(/`([^`]+)`/g, '<code class="bg-gray-100 px-1 rounded">$1</code>') // Inline code
                  .replace(/\n\n/g, '</p><p>') // Double line breaks become paragraph breaks
                  .replace(/\n/g, '<br>'); // Single line breaks become <br>
               
               // Wrap in paragraph tags if not already wrapped
               if (!formattedText.startsWith('<p>')) {
                   formattedText = `<p>${formattedText}</p>`;
               }
               
               // Handle lists
               if (formattedText.includes('<li>')) {
                    formattedText = formattedText.replace(/<p>(<li>.*?)<\/p>/gs, '<ul class="list-disc list-inside mb-2">$1</ul>');
               }
          }
  
            if (!isUser) {
          const avatar = document.createElement('div');
                avatar.className = 'flex-shrink-0 w-8 h-8 rounded-full bg-explo-blue flex items-center justify-center text-white text-sm font-bold mr-3';
                avatar.textContent = 'AI';
                messageContainer.appendChild(avatar);
            }
  
          const messageBubble = document.createElement('div');
            messageBubble.className = `p-3 rounded-xl max-w-[80%] ${isUser ? 'bg-explo-blue text-white ml-auto' : 'bg-gray-200 text-gray-800'}`;
          messageBubble.innerHTML = `<div class="text-sm message-content">${formattedText}</div>`;
  
          if (isUser) {
                const userAvatar = document.createElement('div');
                userAvatar.className = 'flex-shrink-0 w-8 h-8 rounded-full bg-gray-400 flex items-center justify-center text-white text-sm font-bold ml-3';
                userAvatar.textContent = 'U';
              messageContainer.appendChild(messageBubble);
              messageContainer.appendChild(userAvatar);
          } else {
              messageContainer.appendChild(messageBubble);
          }

          chatWindow.appendChild(messageContainer);
            scrollToBottom();
        }

        // Render entire conversation (deprecated - use initializeChatInterface instead)
        function renderConversation() {
            // This function is deprecated to prevent rendering glitches
            // Use initializeChatInterface() instead
            console.warn('renderConversation() is deprecated');
        }

        // Show status message
        function showStatus(element, message, type, showSpinner = false) {
            const statusClasses = {
                'success': 'text-green-600',
                'error': 'text-red-600',
                'info': 'text-blue-600'
            };
            element.className = `text-sm ${statusClasses[type] || 'text-gray-600'}`;
            element.innerHTML = showSpinner ? `${message}<span class="spinner"></span>` : message;
        }

        // Streaming support detection
        function detectStreamingSupport() {
            try {
                return !!(window.ReadableStream && 
                         window.Response && 
                         window.Response.prototype.body &&
                         window.TextDecoder);
            } catch (e) {
                return false;
            }
        }

        const streamingSupported = true;
        console.log('Streaming support:', streamingSupported ? 'Available' : 'Not available');

        // Enhanced message display with streaming support
        function displayStreamingMessage(isUser = false) {
            // Switch from intro to chat mode on first message
            if (conversation.length <= 2) { // System message + first user message
                switchToChatMode();
            }

            const messageContainer = document.createElement('div');
            messageContainer.className = `flex items-start ${isUser ? 'justify-end' : ''}`;

            if (!isUser) {
                const avatar = document.createElement('div');
                avatar.className = 'flex-shrink-0 w-8 h-8 rounded-full bg-explo-blue flex items-center justify-center text-white text-sm font-bold mr-3';
                avatar.textContent = 'AI';
                messageContainer.appendChild(avatar);
            }

            const messageBubble = document.createElement('div');
            messageBubble.className = `p-3 rounded-xl max-w-[80%] ${isUser ? 'bg-explo-blue text-white ml-auto' : 'bg-gray-200 text-gray-800'}`;
            messageBubble.innerHTML = `<div class="text-sm message-content streaming-content"></div>`;

            if (isUser) {
                const userAvatar = document.createElement('div');
                userAvatar.className = 'flex-shrink-0 w-8 h-8 rounded-full bg-gray-400 flex items-center justify-center text-white text-sm font-bold ml-3';
                userAvatar.textContent = 'U';
                messageContainer.appendChild(messageBubble);
                messageContainer.appendChild(userAvatar);
            } else {
                messageContainer.appendChild(messageBubble);
            }

            chatWindow.appendChild(messageContainer);
            scrollToBottom();
            
            return messageBubble.querySelector('.streaming-content');
        }

        // Enhanced markdown formatting function
        function formatMarkdown(text) {
            return text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/^- (.*)/gm, '<li>$1</li>')
                .replace(/`([^`]+)`/g, '<code class="bg-gray-100 px-1 rounded">$1</code>')
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n/g, '<br>')
                .replace(/^(?!<p>)/, '<p>')
                .replace(/(?!<\/p>)$/, '</p>')
                .replace(/<p>(<li>.*?)<\/p>/gs, '<ul class="list-disc list-inside mb-2">$1</ul>');
        }

        // Helper function to clear active input and manage UI state
        function clearActiveInput() {
            const introState = document.getElementById('introState');
            const chatState = document.getElementById('chatState');
            
            if (!introState.classList.contains('hidden')) {
                // In intro mode
                chatInput.value = '';
                autoResizeTextarea(chatInput);
                sendChatBtn.disabled = true;
                document.getElementById('chatSpinner').classList.remove('hidden');
                showStatus(document.getElementById('chatStatus'), 'Thinking...', 'info', true);
            } else {
                // In chat mode
                chatInputChat.value = '';
                autoResizeTextarea(chatInputChat);
                sendChatBtnChat.disabled = true;
                document.getElementById('chatSpinnerChat').classList.remove('hidden');
                showStatus(document.getElementById('chatStatusChat'), 'Thinking...', 'info', true);
            }
        }

        // Helper function to reset UI state
        function resetUIState() {
            sendChatBtn.disabled = false;
            sendChatBtnChat.disabled = false;
            document.getElementById('chatSpinner').classList.add('hidden');
            document.getElementById('chatSpinnerChat').classList.add('hidden');
        }

        // Helper function to get active status element
        function getActiveStatusElement() {
            return document.getElementById('introState').classList.contains('hidden') ? 
                document.getElementById('chatStatusChat') : document.getElementById('chatStatus');
        }

        // Streaming message sender
        async function sendStreamingMessage(messageText) {
            if (!messageText.trim()) return;

            // Add user message
            addMessage('user', messageText);
            clearActiveInput();
            
            addTokens(estimateTokens(messageText));

            // Create streaming AI message container
            const streamingContent = displayStreamingMessage(false);
            let fullResponse = '';

            try {
                const response = await fetch('http://localhost:8080/chat/stream', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'text/event-stream'
                    },
                    body: JSON.stringify({ conversation })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                showStatus(getActiveStatusElement(), 'Receiving response...', 'info');

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            
                            if (data === '[DONE]') {
                                break;
                            }

                            try {
                                const parsed = JSON.parse(data);
                                
                                if (parsed.type === 'chunk') {
                                    fullResponse += parsed.content;
                                    
                                    // Format and display streaming content
                                    const formattedText = formatMarkdown(fullResponse);
                                    streamingContent.innerHTML = formattedText;
                                    scrollToBottom();
                                    addBlinkingCursor(streamingContent);
                                } else if (parsed.type === 'complete') {
                                    fullResponse = parsed.content;
                                    const formattedText = formatMarkdown(fullResponse);
                                    streamingContent.innerHTML = formattedText;
                                    
                                    // Mark streaming as complete and remove cursor
                                    removeBlinkingCursor(streamingContent);
                                } else if (parsed.type === 'error') {
                                    throw new Error(parsed.content);
                                }
                            } catch (parseError) {
                                console.warn('Could not parse SSE data:', data);
                            }
                        }
                    }
                }

                // Remove cursor when streaming is done
                removeBlinkingCursor(streamingContent);
                
                // Add to conversation history
                conversation.push({ role: 'assistant', content: fullResponse });
                saveConversation();
                addTokens(0, estimateTokens(fullResponse));
                showStatus(getActiveStatusElement(), '✓ Response received', 'success');

                // Check for optimization
                if (totalTokens > TOKEN_LIMIT && !isOptimizing) {
                    setTimeout(() => {
                        if (totalTokens > TOKEN_LIMIT && !isOptimizing) {
                            optimizeConversationSilently();
                        }
                    }, 2000);
                }

            } catch (error) {
                console.error('Streaming error:', error);
                
                // Remove cursor from failed streaming message before removing it
                removeBlinkingCursor(streamingContent);
                
                // Remove failed streaming message
                streamingContent.parentElement.parentElement.remove();
                
                // Fallback to non-streaming
                console.log('Falling back to non-streaming...');
                return sendFallbackMessage(messageText);
            } finally {
                resetUIState();
            }
        }

        // Fallback non-streaming message sender
        async function sendFallbackMessage(messageText) {
            showStatus(getActiveStatusElement(), 'Using fallback mode...', 'info');
            
            try {
                const response = await fetch('http://localhost:8080/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ conversation })
                });

                const result = await response.json();
                
                if (response.ok && result.response) {
                    addMessage('assistant', result.response);
                    if (result.tokenUsage) {
                        addTokens(result.tokenUsage.promptTokens || 0, result.tokenUsage.completionTokens || 0);
                    } else {
                        addTokens(0, estimateTokens(result.response));
                    }
                    showStatus(getActiveStatusElement(), '✓ Response received (fallback)', 'success');
                    
                    // Check for optimization
                    if (totalTokens > TOKEN_LIMIT && !isOptimizing) {
                        setTimeout(() => {
                            if (totalTokens > TOKEN_LIMIT && !isOptimizing) {
                                optimizeConversationSilently();
                            }
                        }, 2000);
                    }
                } else {
                    throw new Error(result.error || 'Fallback request failed');
                }
            } catch (fallbackError) {
                console.error('Fallback also failed:', fallbackError);
                showStatus(getActiveStatusElement(), `Error: ${fallbackError.message}`, 'error');
                displayMessage("Sorry, I encountered an error. Please try again.", false);
            }
        }

        // Main send message function with progressive enhancement
        async function sendMessage(messageText) {
            if (!messageText.trim()) return;

            if (streamingSupported) {
                try {
                    return await sendStreamingMessage(messageText);
                } catch (error) {
                    console.warn('Streaming failed, using fallback:', error);
                    return await sendFallbackMessage(messageText);
                }
            } else {
                console.log('Using non-streaming mode for compatibility');
                return await sendFallbackMessage(messageText);
            }
        }

        // Silent token optimization function (background, no user notification)
        async function optimizeConversationSilently() {
            if (isOptimizing) return;
            
            isOptimizing = true;
            try {
                console.log('Silent optimization: Analyzing conversation and extracting PRD information...');
                
                const response = await fetch('http://localhost:8080/optimize', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        conversation: conversation,
                        totalTokens: totalTokens 
                    })
              });
  
              const result = await response.json();
                
                if (response.ok && result.optimizedConversation) {
                    // Replace conversation with optimized version
                    conversation = result.optimizedConversation;
                    saveConversation();
                    
                    // Reset token counter after optimization
                    totalTokens = 0;
                    
                    // Log optimization results silently (no user notification)
                    console.log(`✓ Silent optimization complete: Reduced from ${result.originalTokens} to ${result.optimizedTokens} tokens (${Math.round(((result.originalTokens - result.optimizedTokens) / result.originalTokens) * 100)}% reduction)`);
                    
                    // NO user-visible message - optimization happens silently in background
                    
              } else {
                    console.error('Silent optimization failed:', result.error || 'Optimization failed');
              }

          } catch (error) {
                console.error('Silent optimization error:', error);
                // No user notification for background optimization errors
          } finally {
                isOptimizing = false;
            }
        }

        // Legacy optimization function (kept for any manual calls, but now also silent)
        async function optimizeConversation() {
            return optimizeConversationSilently();
        }

        // Progress bar stages
        const progressStages = [
            { text: "Analyzing conversation history...", percent: 15 },
            { text: "Extracting key product insights...", percent: 30 },
            { text: "Structuring PRD sections...", percent: 50 },
            { text: "Generating detailed content...", percent: 75 },
            { text: "Formatting document...", percent: 90 },
            { text: "Finalizing download...", percent: 99 }
        ];
        let progressInterval = null;
        let currentStage = 0;
        let progressActive = false;

        const progressBarBlock = document.getElementById('progressBarBlock');
        const progressBar = document.getElementById('progressBar');
        const progressStage = document.getElementById('progressStage');
        const progressPercent = document.getElementById('progressPercent');

        function showProgressBar() {
            progressBarBlock.classList.remove('hidden');
            progressBarBlock.style.display = 'block';
            progressBar.style.width = '0%';
            progressPercent.textContent = '0%';
            progressStage.textContent = progressStages[0].text;
            currentStage = 0;
            progressActive = true;
            progressBar.classList.remove('bg-red-600');
            progressBar.classList.add('bg-explo-blue');
            progressInterval = setInterval(() => {
                if (!progressActive) return;
                if (currentStage < progressStages.length) {
                    progressBar.style.width = progressStages[currentStage].percent + '%';
                    progressPercent.textContent = progressStages[currentStage].percent + '%';
                    progressStage.textContent = progressStages[currentStage].text;
                    currentStage++;
                }
            }, 3600); // 3x slower: 1200ms -> 3600ms
        }

        function completeProgressBar() {
            progressActive = false;
            clearInterval(progressInterval);
            progressBar.style.width = '100%';
            progressPercent.textContent = '100%';
            progressStage.textContent = 'Export complete!';
            setTimeout(() => {
                progressBarBlock.classList.add('hidden');
            }, 1200);
        }

        function errorProgressBar(errorMessage = 'Export failed. Please try again.') {
            progressActive = false;
            clearInterval(progressInterval);
            progressBar.style.width = '100%';
            progressBar.classList.remove('bg-explo-blue');
            progressBar.classList.add('bg-red-600');
            progressPercent.textContent = 'Error';
            progressStage.textContent = errorMessage;
            setTimeout(() => {
                progressBarBlock.classList.add('hidden');
            }, 3000); // Show error longer so user can read it
        }

        // Export PRD
        async function exportPRD() {
            if (conversation.length <= 1) {
                showStatus(status, 'Please have a conversation first before exporting', 'error');
              return;
          }

          exportPrdBtn.disabled = true;
            exportSpinner.classList.remove('hidden');
            sendChatBtn.disabled = true;
            sendChatBtnChat.disabled = true;
            showStatus(status, 'Generating PRD...', 'info', true);
            showProgressBar();

            try {
                const response = await fetch('http://localhost:8080/export', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ conversation })
              });
  
              const result = await response.json();
                
              if (response.ok && result.downloadURL) {
                    showStatus(status, 'PRD ready for download!', 'success');
                    completeProgressBar();
                    // Trigger download
                  const a = document.createElement('a');
                  a.href = result.downloadURL;
                  a.download = `Explo_PRD_${new Date().toISOString().slice(0, 10)}.docx`;
                  document.body.appendChild(a);
                  a.click();
                  document.body.removeChild(a);
                    // Show fallback download link after 2 seconds
                    setTimeout(() => {
                        showStatus(status, `PRD generated! <a href="${result.downloadURL}" download="${`Explo_PRD_${new Date().toISOString().slice(0, 10)}.docx`}" class="text-blue-600 hover:underline font-medium">Click here if download didn't start</a>`, 'success');
                    }, 2000);
              } else {
                    // Enhanced error handling with specific messages
                    let errorMessage = 'Export failed. Please try again.';
                    if (result.error) {
                        if (result.error.includes('API key')) {
                            errorMessage = 'Configuration error: OpenAI API key not set up. Please contact support.';
                        } else if (result.error.includes('timeout')) {
                            errorMessage = 'Request timed out. Please try again with a shorter conversation.';
                        } else if (result.error.includes('storage')) {
                            errorMessage = 'File storage error. Please try again in a few moments.';
                        } else if (result.error.includes('Failed to connect')) {
                            errorMessage = 'Network error. Please check your connection and try again.';
                        } else {
                            errorMessage = `Export failed: ${result.error}`;
                        }
                    }
                    errorProgressBar(errorMessage);
                    throw new Error(result.error || 'Failed to generate PRD');
              }

          } catch (error) {
                console.error('Export error:', error);
                let userErrorMessage = 'Export failed. Please try again.';
                
                // Provide specific error messages based on error type
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    userErrorMessage = 'Network error: Unable to connect to the server. Please check your internet connection.';
                } else if (error.message.includes('timeout')) {
                    userErrorMessage = 'Request timed out. The export is taking longer than expected. Please try again.';
                } else if (error.message.includes('API')) {
                    userErrorMessage = 'Service temporarily unavailable. Please try again in a few minutes.';
                } else if (error.message.includes('storage') || error.message.includes('file')) {
                    userErrorMessage = 'File processing error. Please try again with a shorter conversation.';
                } else {
                    userErrorMessage = `Export error: ${error.message}`;
                }
                
                errorProgressBar(userErrorMessage);
                showStatus(status, userErrorMessage, 'error');
          } finally {
              exportPrdBtn.disabled = false;
                exportSpinner.classList.add('hidden');
              sendChatBtn.disabled = false;
              sendChatBtnChat.disabled = false;
            }
        }

        // Clear conversation
        function clearConversation() {
            if (confirm('Are you sure you want to clear the entire conversation? This cannot be undone.')) {
                conversation = [conversation[0]]; // Keep only system message
                saveConversation();
                
                // Reset to intro state
                const introState = document.getElementById('introState');
                const chatState = document.getElementById('chatState');
                introState.classList.remove('hidden');
                chatState.classList.add('hidden');
                
                // Clear both input fields
                chatInput.value = '';
                chatInputChat.value = '';
                
                showStatus(status, 'Conversation cleared', 'success');
            }
        }

        // Event Listeners
        const chatInputChat = document.getElementById('chatInputChat');
        const sendChatBtnChat = document.getElementById('sendChatBtnChat');

        // Intro input handlers
        chatInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage(chatInput.value);
            }
        });

        chatInput.addEventListener('input', autoResizeTextarea);

        sendChatBtn.addEventListener('click', () => {
            sendMessage(chatInput.value);
        });

        // Chat input handlers
        chatInputChat.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage(chatInputChat.value);
            }
        });

        chatInputChat.addEventListener('input', () => {
            autoResizeTextarea.call({ target: chatInputChat });
        });

        sendChatBtnChat.addEventListener('click', () => {
            sendMessage(chatInputChat.value);
        });

        exportPrdBtn.addEventListener('click', exportPRD);
        clearChatBtn.addEventListener('click', clearConversation);

        // Initialize chat interface state
        function initializeChatInterface() {
            const introState = document.getElementById('introState');
            const chatState = document.getElementById('chatState');
            const chatWindow = document.getElementById('chatWindow');
            
            if (conversation.length <= 1) {
                // Show intro state - no conversation exists
                introState.classList.remove('hidden');
                chatState.classList.add('hidden');
                chatState.style.display = 'none';
            } else {
                // Show chat state if conversation exists
                introState.classList.add('hidden');
                chatState.classList.remove('hidden');
                chatState.style.display = 'flex';
                
                // Clear and reload existing messages (skip system message at index 0)
                chatWindow.innerHTML = '';
                for (let i = 1; i < conversation.length; i++) {
                    const message = conversation[i];
                    // Use a direct rendering function that doesn't trigger mode switching
                    renderMessageDirectly(message.content, message.role === 'user');
                }
            }
        }

        // Direct message rendering that doesn't trigger mode switching
        function renderMessageDirectly(text, isUser) {
            const chatWindow = document.getElementById('chatWindow');
            const messageContainer = document.createElement('div');
            messageContainer.className = `flex items-start ${isUser ? 'justify-end' : ''}`;
  
            // Enhanced Markdown to HTML conversion for AI responses
            let formattedText = text;
            if (!isUser) {
                formattedText = formattedText
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // Bold
                    .replace(/\*(.*?)\*/g, '<em>$1</em>') // Italic
                    .replace(/^- (.*)/gm, '<li>$1</li>') // List items
                    .replace(/`([^`]+)`/g, '<code class="bg-gray-100 px-1 rounded">$1</code>') // Inline code
                    .replace(/\n\n/g, '</p><p>') // Double line breaks become paragraph breaks
                    .replace(/\n/g, '<br>'); // Single line breaks become <br>
                 
                 // Wrap in paragraph tags if not already wrapped
                 if (!formattedText.startsWith('<p>')) {
                     formattedText = `<p>${formattedText}</p>`;
                 }
                 
                 // Handle lists
                 if (formattedText.includes('<li>')) {
                      formattedText = formattedText.replace(/<p>(<li>.*?)<\/p>/gs, '<ul class="list-disc list-inside mb-2">$1</ul>');
                 }
            }

            if (!isUser) {
                const avatar = document.createElement('div');
                avatar.className = 'flex-shrink-0 w-8 h-8 rounded-full bg-explo-blue flex items-center justify-center text-white text-sm font-bold mr-3';
                avatar.textContent = 'AI';
                messageContainer.appendChild(avatar);
            }

            const messageBubble = document.createElement('div');
            messageBubble.className = `p-3 rounded-xl max-w-[80%] ${isUser ? 'bg-explo-blue text-white ml-auto' : 'bg-gray-200 text-gray-800'}`;
            messageBubble.innerHTML = `<div class="text-sm message-content">${formattedText}</div>`;

            if (isUser) {
                const userAvatar = document.createElement('div');
                userAvatar.className = 'flex-shrink-0 w-8 h-8 rounded-full bg-gray-400 flex items-center justify-center text-white text-sm font-bold ml-3';
                userAvatar.textContent = 'U';
                messageContainer.appendChild(messageBubble);
                messageContainer.appendChild(userAvatar);
            } else {
                messageContainer.appendChild(messageBubble);
            }

            chatWindow.appendChild(messageContainer);
            scrollToBottom();
        }

        // Switch from intro to chat mode
        function switchToChatMode() {
            const introState = document.getElementById('introState');
            const chatState = document.getElementById('chatState');
            
            introState.classList.add('hidden');
            chatState.classList.remove('hidden');
            chatState.style.display = 'flex';
        }

        // Initialize app
        window.onload = () => {
            loadConversation();
            initializeChatInterface();
            autoResizeTextarea(); // Initialize textarea height
        };

        // Cursor functions removed - no cursor needed for streaming
        function addBlinkingCursor(targetElem) {
            // No cursor needed
        }
        function removeBlinkingCursor(targetElem) {
            // No cursor needed
        }
    </script>
</body>
</html>